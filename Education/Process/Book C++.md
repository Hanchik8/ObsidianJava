---
Done: false
Time: 30
Info:
  - Minutes
---
 1) Рекурсия - повторение, вызов самого себя.  Любая функция допускает рекурсивное обращение к себе. (Си) В языке программирования C любая функция может вызывать саму себя, то есть быть рекурсивной. Это означает, что в теле функции может присутствовать вызов этой же функции. Однако, для корректной работы рекурсивной функции необходимо, чтобы она была правильно спроектирована с учетом базового случая и прогрессивного приближения к нему, как было описано ранее.
        include <stdio.h>

             // Функция, считающая факториал
              int factorial(int n);
             int main() {
            int num = 5;
            printf("Факториал %d равен %d\n", num, factorial(num));
                 return 0;
                }
                int factorial(int n) {
                  if (n == 0) { // Базовый случай
                         return 1;
                        } else {
                        return n * factorial(n - 1); // Рекурсивный вызов
                        }
                                       }

 2) В языке программирования C определения функций не могут быть вложенными друг в друга. Это означает, что вы не можете объявить или определить одну функцию внутри тела другой функции. Вложенность функции в C запрещена, но можно вызывать одну функцию внутри другой.
        include <stdio.h>
     
    // Объявление функций на уровне файла
    void innerFunction();
    void outerFunction();

    int main() {
    outerFunction();
    return 0;
    }

    // Определение функции outerFunction
    void outerFunction() {
    printf("This is the outer function.\n");
    innerFunction(); // Вызов другой функции
    }

    // Определение функции innerFunction
    void innerFunction() {
    printf("This is the inner function.\n");
    }
3) Указатели - дают информацию не о значении а об адресе. Разве операций будет не больше? Тип тогда уж легче сразу направить на значение чем на адрес а потом выводить через этот адрес значение. 
        include <stdio.h>
        int main() {
        int a = 10;  // Переменная a
        int *p = &a; // Указатель p хранит адрес переменной a

        printf("Значение a: %d\n", a);
          printf("Адрес a: %p\n", (void*)&a);
          printf("Значение через указатель p: %d\n", *p);
          return 0;
        }
        1. **Переменная `a`**:
    
    - Хранит значение `10`.
    - Адрес этой переменной может быть, например, `0x7ffee3b23c9c` (значение зависит от компилятора и системы).
        2. **Указатель `p`**:
    
    - Хранит адрес переменной `a`.
    - Если `a` находится по адресу `0x7ffee3b23c9c`, то `p` будет содержать это значение.
        3. **Вывод адреса и значения**:
    
    - `printf("Адрес a: %p\n", (void*)&a);` выводит адрес переменной `a`.
    - `printf("Значение через указатель p: %d\n", *p);` выводит значение, хранящееся по адресу, на который указывает `
int; long (32 bites); long long (64 bites). 32 bites= +-2'31.
char (1 bite); 
float(редкий, не стоит); double цифры с плавающей точкой.
bool= true/false.
unsigned= префикс, без знаковое число т.е. без минуса. Не от -2'31 до 2'31-1, а от 0 до 2'32-1.
Можно использовать с char;int;long;long long. Можно писать просто insigned, всё равно авто будет стоять int.

Идентификаторы
if;else;for;do;while;switch;class;struct and ect.
Std -префикс 
Cout - вывод
std и cout не зарезервированные слова и их по сути можно использовать только если прописать std::cout
using std::cout => cout

Литералы
true; false; "abc"; "a";  0.2f; nullptr;
bool x = true
x=true;
int - используется для целых чисел и даже 5.0
double - для дробных чисел, 5.6 0.4f.
Любое значение кроме 0 в использовании bool = true. (0 = false)
при использовании int(целочисленный идентификатор) дробные значение не смогут прописываться в полной мере => 5/3=1. Чтобы исправить это достаточно поставить точку, так число уже будет считать как double.
При использовании long long x = 10000000000000000000 может возникнуть ошибка ведь любое целочисленное число считается как int (Сейчас нет, компилятор всё делает автоматически) и не может быть больше 2'31-1, тогда необходимо использовать префиксы по типу:
0.2f = 0.2 float; 0.3ll = long long and ect.

Разница между объявлением и определением. Любое определение является объявлением, но не наоборот. Можно объявить но не определить, на примере функций.
int f(int,char);

Можно объявлять одну и ту же переменную в разных областях видимости. (scope's)
int f(...) {
int x;         {  int x "внутренняя область видимости более важнее, и работать будет тот х который внутри-внутри";                                           } 
}
    ((((Если же я хочу обратиться к иксу который был использован дважды в иксе, через внутренние скобки через ::x. Этим способом следует пользоваться если он еще не был использован ранее.)))) Это не точно и скорее всего ложь.
Читать стандарт в спорных ситуациях.
int f(...) {
int x=2 ; { int x=x; }
}
int f(...) {
int x=2 ; { int x[x]; }
}
непонятно что получилось.
[] - массивы

Выражения (expressions)
Смесь идентификаторов и литералов объединенные операторами.
5+х ; 2 ; f (3) ; ++у ;  всё это выражения
Арифметические операторы: -, +,* ,/ ,% 
">>"; <<  -  операторы побитового сдвига >> умножить дважды
&; && ; |; || - конъюнкция и дизъюнкция соответственно.
    ![[Pasted image 20240726125545.png]]
    ![[Pasted image 20240726125804.png]]
Двоенные операторы используют bool и выводят bool
Одиночные (&) используют int т.е. целые числа
т.е. использовав целые числа в двоенных операторах они конвертируются в bool.
Оператор ! - "not;не" bool
Оператор = - (присваивания) lvalue, left side value. Выражение которое может стоять с лева от оператора присваивания. (rvalue выражение которое не может)
х - rvalue
5 - leftvalue
х=у=3 => x=3 
(x=3)=5 =>x(3)=5 => x(5) (не просто 5, а переменная с характеристикой 5)
if (x=3) сделай что-нибудь, это присваивание, а не сравнение.
правильно = if (x"="="3) (кавычки не читай).
Операторы составного присваивания: +=; -=; * =; /=; %=; >>=; <<=; &=; ^=; |=;
x+=y (эффективнее)
x=x+y (менее эффективно)
Операторы сравнения:
'='=';!=;<;>;<=;>=; возвращают bool
тернарный оператор - требует три аргумента '?:'
x?y:z 
Если х равен 5, то у=3, а z=z. Если нет ничего не случиться.
x= (x'='='5) ? (y=3) : (z=7)
В данном случае проверяется равен ли х 5, если да (True), то совершается левое значение, если нет (False), принимается значение правой части.
х превратится либо х=у, либо х=z
этот оператор используется вместо - 
if ....
    return....
         else return...

using namespace std;
 int main() {
    int score = 75;
    string result = (score >= 60) ? "Passed" : "Failed";
    cout << "Результат: " << result << endl;
    return 0;
    }

Префиксный и постфиксный инкремент:
++х; берёт х прибавляет 1 и подставляет его на место; то что получилось является lvalue
x++; берёт х увеличивает его на 1, а возвращает, то что было, т.е. копию временно созданную до того как его увеличили.
Префиксный быстрее т.к. не создаёт копию. Он предпочтительней когда не важен результат. (Разве результат не всегда важен?)
sizeof() - возвращает количество байт которое занимает объект внутри. Можно как от переменной так и от 'название типа'
Оператор , - вычисляет левую и правую часть и возвращает значение правой части.
х=(х=5,y=3,z++,7) => x=7
x=(3,8) => x=8
У оператора запятая самый низкий приоритет. В функции f(5,4); нету оператора запятая это просто синтаксис вызова функции 
int x=5; это не оператор присваивания, это просто объявление (инициализация), проще говоря, это просто необходимый синтаксис.
 
Управляющие конструкции
if (bool-expression) statement  - инструкция 