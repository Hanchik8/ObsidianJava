Числа с отсылкой/связкой на int -- short, int, long (92103910L). 
Напоминает с++ с привязкой с постфиксами.
short and float -- 64bit and 32bit respectively.
[Book C++](Book%20C++.md) 
*sentences for installing JDK17 in OS ubuntu:*
sudo apt update
sudo apt install openjdk-17-jdk
*for searching every allowed ports in the server(VPS):*
sudo ufw status




### Герберт Шилдт
**Инкапсуляция** — это принцип объектно-ориентированного программирования, который скрывает внутренние данные объекта и ограничивает доступ к ним, предоставляя взаимодействие через специально определённые методы (геттеры и сеттеры). Это защищает данные от неправильного использования и делает код более безопасным и управляемым.
	class Person { 
	// _Приватные поля (скрыты для внешнего доступа)_
	private String name; private int age; 
	// _Конструктор для инициализации объекта_
	public Person(String name, int age) { 
	this.name = name; this.age = age; } 
	// _Публичные методы (геттеры и сеттеры) для доступа к полям_
	public String getName() { 
	return name; // _Вернуть имя_ } 
	public void setName(String name) { 
	this.name = name; // _Установить новое имя_ } 
	public int getAge() { 
	return age; // _Вернуть возраст_ }
	}
**Наследование** в Java — это механизм, позволяющий создавать новый класс на основе уже существующего. Новый класс (наследник) получает все свойства и методы родительского класса и может добавлять свои или изменять унаследованные.
		// Родительский класс
		class Animal {
	    private String name;
	
	    // Конструктор родительского класса
	    public Animal(String name) {
	        this.name = name;
	    }
	
	    // Метод, который выводит звук животного
	    public void makeSound() {
	        System.out.println("Животное издает звук");
	    }
	
	    public String getName() {
	        return name;
	    }
	}
	// Класс-наследник
	class Dog extends Animal {
	    // Конструктор наследника
	    public Dog(String name) {
	        super(name); // Вызов конструктора родительского класса
	    }
	
	    // Переопределение метода родительского класса
	    @Override
	    public void makeSound() {
	        System.out.println("Собака лает");
	    }
	
	    // Новый метод, которого нет в родительском классе
	    public void fetch() {
	        System.out.println(getName() + " приносит мяч!");
	    }
	}
	public class Main {
	    public static void main(String[] args) {
	        // Создаем объект родительского класса
	        Animal animal = new Animal("Животное");
	        animal.makeSound();  // Вывод: Животное издает звук
	
	        // Создаем объект класса-наследника
	        Dog dog = new Dog("Бобик");
	        dog.makeSound();  // Вывод: Собака лает
	        dog.fetch();      // Вывод: Бобик приносит мяч!
	    }
	}
**Полиморфизм** в Java — это одно из ключевых понятий объектно-ориентированного программирования (ООП), которое позволяет объектам принимать множество форм. Это означает, что один и тот же метод может работать по-разному в зависимости от объекта, который его вызывает. Основная цель полиморфизма — упростить управление сложными системами, используя общие интерфейсы или базовые классы.
	class MathOperations {
	 // Перегрузка метода add 
	 public int add(int a, int b) { 
		 return a + b; } 
	 public double add(double a, double b) { 
		 return a + b; } 
	 public int add(int a, int b, int c) { 
		 return a + b + c; } 
	 }
		 System.out.println(math.add(2, 3)); // Вызов метода add(int, int) System.out.println(math.add(2.5, 3.7)); // Вызов метода add(double, double) System.out.println(math.add(1, 2, 3)); // Вызов метода add(int, int, int)
java не поддерживает целочисленные значения без знака
Конечно, давай рассмотрим мои ответы на каждый вопрос и сравним с твоими, чтобы выявить различия и увидеть, что можно улучшить:

1. **Что такое платформа Java и почему она считается независимой от архитектуры?**

   **Мой ответ**: Java — это программная платформа, которая состоит из языка программирования Java и среды выполнения (JVM). Программы на Java компилируются в байт-код, который может выполняться на любой платформе, где установлена JVM. Это и обеспечивает независимость от архитектуры, так как байт-код не привязан к конкретному устройству.

   **Разница**: Ты упомянул только JVM, но не объяснил процесс компиляции в байт-код, который является ключевым моментом. Это важно для полного понимания.

   **Что улучшить**: Попробуй объяснять концепции с полным описанием процесса, а не только с конечным результатом. В данном случае нужно было упомянуть, что код сначала компилируется в байт-код, который уже потом выполняется JVM.

2. **Какова роль Java Virtual Machine (JVM) в выполнении программ на Java?**

   **Мой ответ**: JVM выполняет байт-код программы, интерпретируя его в машинные команды конкретного устройства. Она также управляет памятью и обеспечивает работу сборщика мусора, что делает Java безопасным и эффективным языком для выполнения программ на разных платформах.

   **Разница**: Ты правильно упомянул возможность выполнения программ на разных устройствах, но не отметил роль JVM в управлении памятью и обеспечении безопасности.

   **Что улучшить**: Попробуй углубиться в роль JVM, чтобы лучше понимать ее функции. Например, что она занимается не только интерпретацией кода, но и сбором мусора.

3. **Какие ключевые особенности языка Java делают его безопасным и надежным для использования в крупных проектах?**

   **Мой ответ**: Безопасность Java обеспечивается строгой типизацией, сборкой мусора, проверкой байт-кода на выполнение только разрешённых операций (sandbox) и наличием встроенных механизмов безопасности (например, управление доступом к памяти). Объектно-ориентированность способствует надёжности и удобству для крупных проектов.

   **Разница**: Ты указал объектно-ориентированность и строгую типизацию, что верно, но пропустил такие аспекты, как сборка мусора и механизм безопасности, что также очень важно.

   **Что улучшить**: Прочти подробнее про механизмы безопасности и сборку мусора в Java, чтобы лучше понимать, почему этот язык так популярен в крупных проектах.

4. **Что такое компилятор в Java, и каков процесс компиляции и выполнения программы на Java?**

   **Мой ответ**: Компилятор Java переводит исходный код в байт-код, который не привязан к конкретной архитектуре. Затем этот байт-код выполняется на JVM, которая интерпретирует его и запускает на конкретной платформе.

   **Разница**: Ты дал правильный ответ, но не уточнил, что компилятор переводит код именно в байт-код, который является независимым от архитектуры.

   **Что улучшить**: Больше внимания к деталям процесса: от исходного кода до выполнения на JVM.

5. **Какую структуру имеет простейшая программа на Java, и какие ключевые элементы обязательно должны присутствовать в коде?**

   **Мой ответ**: Простейшая программа на Java выглядит так:
   ```java
   public class HelloWorld {
       public static void main(String[] args) {
           System.out.println("Hello, World!");
       }
   }
   ```
   Обязательно должны быть: объявление класса (`public class`), метод `main`, который является точкой входа в программу, и вызов метода `System.out.println()` для вывода текста.

   **Разница**: Твой ответ правильный, но ты использовал сокращения вроде `psvm` вместо полной записи `public static void main`. Полная запись лучше для того, чтобы показать понимание синтаксиса.

   **Что улучшить**: Используй полные синтаксические конструкции в ответах, чтобы быть точным и избегать недопониманий.

6. **Что такое `public static void main(String[] args)` и почему эта конструкция обязательна для запуска программы?**

   **Мой ответ**: Метод `public static void main(String[] args)` — это точка входа в любую программу на Java. JVM ищет этот метод для того, чтобы запустить программу. Он должен быть `public` (общедоступным), `static` (чтобы его можно было вызвать без создания объекта), и возвращать `void` (без возврата значения).

   **Разница**: Ты указал, что метод `main` — ключ для запуска программы, но не объяснил, почему нужны модификаторы `public` и `static`.

   **Что улучшить**: Прочти про ключевые слова `public`, `static` и `void` в контексте метода `main`, чтобы полностью понимать их роль.

7. **Какие типы комментариев используются в языке Java? Приведи примеры.**

   **Мой ответ**: В Java используются три типа комментариев: 
   - Однострочные: `//`
   - Многострочные: `/* ... */`
   - Комментарии для JavaDoc: `/** ... */`.

   **Разница**: Твой ответ правильный.

   **Что улучшить**: Нечего улучшать, твой ответ верный.

8. **Объясни разницу между типами данных `int`, `long`, `float` и `double`. Когда целесообразно использовать каждый из них?**

   **Мой ответ**: 
   - `int` — целочисленные значения (32 бита).
   - `long` — большие целочисленные значения (64 бита).
   - `float` — числа с плавающей точкой (32 бита).
   - `double` — числа с плавающей точкой с большей точностью (64 бита).
   `float` используется для менее точных вычислений, а `double` — для более точных.

   **Разница**: Ты правильно указал разницу между типами, но допустил ошибку в размере битов у `float` и `double`.

   **Что улучшить**: Обрати внимание на точные размеры типов данных.

9. **Что такое переменные в Java и какие правила их объявления? Приведи пример объявления переменной.**

   **Мой ответ**: Переменные — это именованные области памяти, в которых хранятся данные. Для объявления переменной нужно указать её тип и имя. Пример:
   ```java
   int x = 0;
   ```

   **Разница**: Ты тоже правильно объяснил понятие переменной, но стоит более точно описывать переменные как "области памяти для хранения данных".

   **Что улучшить**: Немного более точная формулировка определения переменной.

10. **Что такое управляющие структуры в Java? Приведи примеры использования условного оператора `if-else`.**

   **Мой ответ**: Управляющие структуры — это конструкции, которые изменяют поток выполнения программы. Пример:
   ```java
   if (a % 2 == 0) {
       System.out.println("Чётное");
   } else {
       System.out.println("Нечётное");
   }
   ```

   **Разница**: Ты правильно объяснил `if-else`. Отличий нет.

   **Что улучшить**: Нечего улучшать, всё верно.

11. **Как работает оператор `switch`, и в каких ситуациях его целесообразно использовать вместо `if-else`?**

   **Мой ответ**: Оператор `switch` проверяет значение переменной и выполняет соответствующий `case`. Пример:
   ```java
   switch (day) {
       case 1:
           System.out.println("Понедельник");
           break;
       case 2:
           System.out.println("Вторник");
           break;
       default:
           System.out.println("Неизвестный день");
   }
   ```
   Используй `switch`, когда нужно проверить несколько значений одной переменной.

   **Разница**: Ты ошибочно описал `switch` как цикл. Это условная конструкция, а не цикл.

   **Что улучшить**: Убедись, что `switch` — это не цикл, а конструкция для проверки значений переменной.

12. **Что такое цикл `for` в Java, и чем он отличается от цикла `while`? Приведи пример использования цикла `for`.**

   **Мой ответ**: Цикл `for` используется, когда количество итераций известно заранее. Он включает три части: инициализация, условие и инкремент/декремент. Пример:
   ```java
   for (int i = 0; i < 5; i++) {
       System.out.println(i);
   }
   ```

   **Разница**: Твой ответ правильный.

   **Что улучшить**: Нечего улучшать.

13. **Объясни разницу между постфиксной и префиксной формой инкремента и декремента (`++` и `--`) в Java. Как это влияет на производительность?**

   **Мой ответ**: Постфиксная форма (`i++`) возвращает текущее значение `i`, а затем увеличивает его, тогда как префиксная форма (`++i`) сначала увеличивает `i`, а затем возвращает его. Префиксная форма может быть немного быстрее, так как не создаёт временную копию.

   **Разница**: Ты правильно объяснил разницу между формами, но не обязательно касался производительности. В большинстве случаев разница незначительна.

   **Что улучшить**: Не обязательно углубляться в производительность, но можно добавить, что в большинстве ситуаций разница в производительности несущественна.

14. **Что такое массивы в Java? Как они объявляются и инициализируются?**

   **Мой ответ**: Массивы — это структуры данных, которые могут хранить несколько значений одного типа. Они объявляются с помощью синтаксиса:
   ```java
   int[] array = new int[5]; // объявление массива на 5 элементов
   ```

   **Разница**: Ты не затронул, как инициализировать массивы при объявлении. Это важный момент.

   **Что улучшить**: Упомяни способ инициализации, например:
   ```java
   int[] array = {1, 2, 3, 4, 5}; // инициализация массива
   ```

15. **Что такое приоритет операторов в Java? Как это влияет на порядок выполнения выражений?**

   **Мой ответ**: Приоритет операторов определяет, какой оператор будет выполнен первым в выражении. Например, умножение имеет более высокий приоритет, чем сложение:
   ```java
   int result = 2 + 3 * 4; // результат будет 14, а не 20
   ```

   **Разница**: Ты не упомянул о приоритете операторов и о том, как они влияют на выполнение. Это важный аспект.

   **Что улучшить**: Включи в ответ описание того, как приоритет операторов влияет на выполнение выражений и используй примеры для наглядности.

---
Сhar - в java используется для хранения символов, Char является 16-битным (от 0 до 65_535). Стандартный набор символов - ASCII (0-127).

В следующей программе демонстрируется применение переменных char: // Демонстрация использования типа данных char. class CharDemo { puЫic static void main ( String [] a rgs ) { char chl, ch2 ; chl = 88; // код для Х ch2 = 'У' ; System . out .print ( " chl и ch2 : " ) ; System.out . println (chl +" "+ ch2); Вот вывод, отображаемый в результате выполнения программы: chl и ch2 : Х У.

Шестнадцатеричная константа указывается с ведущим нулем и буквой "Х" (Ох или ОХ). Диапазон шестнадцатеричных цифр - от О до 15, так что числа от 10 до 15 заменяются буквами от А до F (или от а до f).

Когда значение 257 приводится к типу byte, результатом будет остаток от деления 257 на 256 (диапазон byte), который в данном случае равен 1. Когда значение переменной d преобразуется в тип int, его дробная часть утрачивается. Когда значение переменной d преобразуется в тип byte, его дробная часть теряется, а значение уменьшается по модулю 256, что в этом случае дает 67.

Инициализация - присваивание переменной какого-либо значения.

- **ПП:** Основывается на логике выполнения программы: сначала одно действие, затем другое. Используются структуры вроде циклов и условных операторов.
- **ООП:** Опирается на 4 основных принципа:
    - **Инкапсуляция:** Объекты скрывают внутреннюю реализацию.
    - **Наследование:** Классы могут наследовать свойства и методы других классов.
    - **Полиморфизм:** Один интерфейс может использоваться для разных реализаций.
    - **Абстракция:** Скрываются детали реализации, остаётся только необходимый функционал.
 
**Ключевое слово static**
Mодификатор который позволяет выделять память и связывать переменные между классами, и делать их единым между ними. Следует знать что static инициализируется в более приоритетном порядке (т.е. первым нежели другие ключевые слова).
**Garbage Collector**
В java есть встроенный сборщик мусора, он удаляет объекты если на них больше не имеется никаких ссылок (Date date = new Date()). На данный момент существует команда просящая java о вызове GC, но не гарантирующая этого. Это System.gc(), проще говоря он просит java вызвать сборщик мусора, но если GC считает что для этого нет необходимости он не вызовется. 
У JVM есть параметры запуска По умолчанию они -Xms128m -Xmx750m Xms это размер памяти JVM по умолчанию Xmx это максимальный размер памяти JVM Есть память занимается больше Xms - память немного увеличивается, максимально до Xmx, если  больше Xmx - получаем OutOfMemoryError Поменять можно в файле idea.vmoptions, который находится в Help > Edit Custom VM Options с перезапуском IDEA или прописать поля в Main > Edit Configurations > VM options (totalMemory()-freeMemory())/1024/1024 сколько заняла программа в мегабайтах.
Говорилось о том, что чтобы удалить ссылку на объект (GC его удалил), нужно пометить его как null. Но в комментариях увидел:
Присвоение null в цикле ничего не дает, так как после выхода за его пределы в любом случае объекты уйдут к GC Компилятор содержимое цикла представит как: new Date(); Object var2 = null;
Имелся метод finalize() который также запускался с GC благодаря ему, можно было отследить работал ли GC, но с 9 версии java он был помечен как @Deprecated (Устаревший).
**Перегрузка методов**
![](Pasted%20image%2020250125204038.png)
В первую очередь расширение до int or long. Далее автобоксинг до оберток (Label) и в последнюю очередь поиск массивных типов.
**String**
`String` удобен для простых операций с текстом, особенно если он часто используется как ключ (например, в `HashMap`) или редко изменяется.
`StringBuilder` — выбор для сложных и частых модификаций строк, так как он быстрее и экономичнее в работе с памятью.