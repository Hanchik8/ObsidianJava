Создавая игру/проект необходимо для начала разбить его/её на простые действия:
Игра угадай число - поглядев на это краткое изложение, первое, что мы можем сделать -- это начать разбивать его на простые действия, максимально думая как программист:

1. Сгенерировать случайное число между 1 и 100.
2. Начать запись количества попыток игрока угадать число. Начать с 1.
3. Предоставить попытку угадать игроку загаданное число.
4. Как только попытка угадать была отправлена, сначала записать её где-нибудь, чтобы пользователь мог увидеть свои предыдущие попытки
5. Далее, проверить было ли это число верным.
6. Если число верное:
    1. Показать поздравительное сообщение.
    2. Оградить игрока от дальнейшей возможности ввода чисел (это испортит игру).
    3. Предоставить возможность для перезапуска игры.
7. Если число не верное и есть попытки:
    1. Сказать игроку, что он не угадал.
    2. Разрешить ему использовать ещё попытку.
    3. Повысить число попыток на 1.
8. Если число не верное и попыток нет:
    1. Сказать игроку, что игра окончена.
    2. Оградить игрока от дальнейшей возможности ввода чисел (это испортит игру).
    3. Предоставить возможность для перезапуска игры.
9. Во время перезапуска игры убедиться, что игровая логика и пользовательский интерфейс полностью сбросились на начальные значения и далее перейти обратно к пункту 1.


 Разные движки имеют разные «кодовые имена». Например:

- [V8](https://ru.wikipedia.org/wiki/V8_(%D0%B4%D0%B2%D0%B8%D0%B6%D0%BE%D0%BA_JavaScript)) – в Chrome, Opera и Edge.
- [SpiderMonkey](https://ru.wikipedia.org/wiki/SpiderMonkey) – в Firefox.
- …Ещё есть «Chakra» для IE, «JavaScriptCore», «Nitro» и «SquirrelFish» для Safari и т.д.
Моя первая сложная задача:
for( simple = 1; simple <= 100 ; ++simple) {
   if (simple == 2 ) {
      alert (simple)
     };
     if (simple == 3){
      alert(simple)
     } ;
     if (simple == 5){
      alert(simple)
      } ;
      if (((simple%2 == 0) && (simple% 3 == 0)) || ((simple%5==0) && (simple%2==0)) || simple%3==0 || simple%2==0 || simple==1 || simple%5==0) continue;
      alert (simple)
    }
FAST BUTTONS:
– «Resume»: продолжить выполнение, быстрая клавиша F8. (на ноуте с помощью + fn)
– «Step»: выполнить следующую команду, быстрая клавиша F9.
–«Step over»: выполнить следующую команду, но _не заходя внутрь функции_, быстрая клавиша F10.
– «Step into», быстрая клавиша F11. Это похоже на «Step», но ведёт себя по-другому в случае асинхронных вызовов функций.
– «Step out»: продолжить выполнение до завершения текущей функции, быстрая клавиша Shift+F11.



Движки JavaScript применяют множество оптимизаций, чтобы она работала быстрее и не задерживала выполнение кода.
Вот некоторые из оптимизаций:

- **Сборка по поколениям (Generational collection)** – объекты делятся на два набора: «новые» и «старые». В типичном коде многие объекты имеют короткую жизнь: они появляются, выполняют свою работу и быстро умирают, так что имеет смысл отслеживать новые объекты и, если это так, быстро очищать от них память. Те, которые выживают достаточно долго, становятся «старыми» и проверяются реже.
- **Инкрементальная сборка (Incremental collection)** – если объектов много, и мы пытаемся обойти и пометить весь набор объектов сразу, это может занять некоторое время и привести к видимым задержкам в выполнении скрипта. Так что движок делит всё множество объектов на части, и далее очищает их одну за другой. Получается несколько небольших сборок мусора вместо одной всеобщей. Это требует дополнительного учёта для отслеживания изменений между частями, но зато получается много крошечных задержек вместо одной большой.
- **Сборка в свободное время (Idle-time collection)** – чтобы уменьшить возможное влияние на производительность, сборщик мусора старается работать только во время простоя процессора.
 1)Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
 2)Объекты сохраняются в памяти, пока они достижимы.
 3)Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня): набор взаимосвязанных объектов может стать недоступен в целом, как мы видели в примере выше.
 
for (let key in user) {
  alert(key)
  alert(user[key]);
} 
**Мой первый проект:**
Всем привет! Я создал сайт для нашего потока. На нём можно будет оставить свои данные, такие как имя, номер курса и увлечение. Это небольшой шаг, чтобы нам всем было проще познакомиться и начать общение перед началом занятий. Вот ссылка на сайт: [https://capable-wisp-661a66.netlify.app/](https://capable-wisp-661a66.netlify.app/) Надеюсь, что этот сайт поможет нам немного лучше узнать друг друга. Заходите, если захотите. P.S. Сайт лучше всего работает на экранах больше 1000 пикселей (т.е. на ноутбуках и компьютерах) и не очень оптимизирован под мобильные устройства.
